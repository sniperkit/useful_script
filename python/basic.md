1.文档字符串可以通过name.__doc__来访问，其中name可以是包名也可以是函数名。
2.使用help函数可以获取函数或者包的文档字符串.
	help(os)
	hlep(os.open)
3.使用class的__bases__属性，可以获取类的基类.
4.使用isinstance方法来检查一个对象是否是一个类的实例.
5.想要知道某个对象属于某一个类，可以使用它的__class__属性.
6.使用hasattr方法可已检查某一个对象是否包含某一个属性。
7.使用hasattr(x.'__call__')来检查某个对象是否可以被调用（函数）.
8.使用setattr来为一个对象设置属性.
9.导入一个包以后，可以通过dir(package_name)来获取包内的所有常量，函数，类定义...
10. __init__方法是提供了一个类的构造函数.
11. __del__方法提供了析构函数的功能，但是其调用时机是随机的，因此不建议使用。
12.当前类和对象可以作为super函数的参数使用，调用函数返回的对象的任何方法都是调用超类的方法，而不是当前类的方法。
13.静态方法没又self参数，并且可以被类本身直接调用.
14.类成员方法在定义时需要名为cls的类似self的参数，类成员方法可以直接使用类名调用。但是cls参数时直接被绑定到类的.
15.想要告知程序本身是做为程序运行还是作为库导入到其他程序，可以使用__name__变量：在main程序中，__name__变量的值为__main__。而在导入模块中该值被设置为模块的名称。
16.获取python模块搜索路径的方法：(也就是说放置在这些路径中模块可以被python解释器找到)
	>>> import sys, pprint
	>>> pprint.pprint(sys.path)
17.可通过修改PYTHONPATH环境变量来告诉python解释器去那里找模块定义.(自定以模块路径)
18.包含模块代码的文件的名字要和模块名一样，再加上.py扩展名.
19.当模块存储在文件中时，包就时模块所在的目录。为了让python解释器将其作为包对待，该目录下必须包含一个__init__.py的文件。为了将模块放在包内，直接将模块放在包目录内即可.
20.查看模块包含的内容可以使用dir函数.它会将对象的所有特性（一起模块的所有函数，类，变量等）列出。
21.__all__定义了一个模块的共有接口，它告诉python解释器：从模块导入所有名字代表什么含义.如果没有设置__all___ ， import * 语句会导入模块中所有不以__开头的全局名称.
22.模块的__file__属性可以用来获取模块的源码路径.
23. python3.6 -m pip install Pillow
24. sudo vim /etc/sudoers
	secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin
25.可以用help函数来获取某一对象的所有属性.
26.如果想查看是否引入了正确的模块，可以通过打印模块的__file__属性来查看模块路径。通过打印模块的__doc__属性来查看该模块的文档。通过help函数来获取该模块的帮助信息。
27. CPython是python官方的解释器，它用C语言编写。
28. IPython是基于CPython的一个交互式解释器。CPython使用>>>作为提示符，而IPython使用In[序号]:作为提示符。
29. PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译，所以可以显著提高Python代码的执行速度。
30. Jython是运行在Java平台上的Python解释器，可以直接将Python代码编译为Java字节码执行。
31. IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Pyton代码编译为.Net的字节码。
32. 以#开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块。
33. 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符.
34. 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。Python对bytes类型的数据用带b前缀的单引号或双引号表示：
		x = b'ABC'
	要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。
35. 以Unicode表示的str通过encode()方法可以编码为指定的bytes.
36. 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法.
37. 要计算str包含多少个字符，可以用len()函数。
38. 为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。
39. 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。
	尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
40. 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。可以使用isinstance()判断一个对象是否是Iterator对象
	凡是可作用于for循环的对象都是Iterable类型；
	凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；
41. 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数.
	编写高阶函数，就是让函数的参数能够接收别的函数
42. 使用__slots__: 如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性：
43. 可以对所有实现了__iter__方法的对象行进迭代。__iter__方法返回一个迭代器（iterator)，所谓的迭代器就是实现了__next__方法的对象.next函数其实就是调用了迭代器的__next__方法。
43. 一个实现了__iter__方法的对象是可迭代的，一个实现了__next__方法的对象是迭代器。
44. 凡是可用作for循环的对象都是Iterable类型。凡是可用作于next()函数的对象都是Iterator类型，它表示一个惰性计算的序列。
45. 集合数据类型如list, dict, str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。
46. python的for循环本质上就是通过不断调用next()函数实现的。
47. 使用type()函数来获取一个对象的类型。
48. 先定义metaclass，然后创建类，最后就可以创建类的实例了。metaclass允许你创建类或者修改类，换句话说，你可以把类看成是metaclass创建出来的实例。
